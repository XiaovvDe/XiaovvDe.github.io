<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Flowable学习笔记 讲清涉及的关键表</title>
    <link href="/2025/01/30/flowable%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/01/30/flowable%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="flowable最贴心的入门案例，讲清涉及的关键表"><a href="#flowable最贴心的入门案例，讲清涉及的关键表" class="headerlink" title="flowable最贴心的入门案例，讲清涉及的关键表"></a>flowable最贴心的入门案例，讲清涉及的关键表</h1><h2 id="flowable基本配置"><a href="#flowable基本配置" class="headerlink" title="flowable基本配置"></a>flowable基本配置</h2><ol><li>导入如下jar包，包括flowable的核心包，日志包以及mysql包<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.flowable<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>flowable-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>在resources中新建log4j.properties文件，在控制台打印数据库操作相关信息，内容如下：<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mel">log4j.rootLogger=DEBUG, CA<br>log4j.appender.CA=org.apache.log4j.ConsoleAppender<br>log4j.appender.CA.<span class="hljs-keyword">layout</span>=org.apache.log4j.PatternLayout<br>log4j.appender.CA.<span class="hljs-keyword">layout</span>.ConversionPattern= %d&#123;hh:mm:ss,SSS&#125; [%t] %-<span class="hljs-number">5</span>p %c %x - %m%n<br></code></pre></td></tr></table></figure></li><li>获取流程引擎<br>代码如下所示，通过简单的方式进行数据库配置和流程引擎的获取，后续的各种操作都依赖于流程引擎。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ProcessEngineConfiguration</span> <span class="hljs-variable">cfg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StandaloneProcessEngineConfiguration</span>()<br>                .setJdbcUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/flowable-learn?serverTimezone=UTC&amp;nullCatalogMeansCurrent=true&quot;</span>)<br>                .setJdbcUsername(<span class="hljs-string">&quot;root&quot;</span>)<br>                .setJdbcPassword(<span class="hljs-string">&quot;root&quot;</span>)<br>                .setJdbcDriver(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>)<br>                .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_DROP_CREATE);<br>        <span class="hljs-type">ProcessEngine</span> <span class="hljs-variable">processEngine</span> <span class="hljs-operator">=</span> cfg.buildProcessEngine();<br></code></pre></td></tr></table></figure>配置数据库时有四种配置，如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DB_SCHEMA_UPDATE_FALSE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;false&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DB_SCHEMA_UPDATE_CREATE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;create&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DB_SCHEMA_UPDATE_CREATE_DROP</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;create-drop&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DB_SCHEMA_UPDATE_DROP_CREATE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;drop-create&quot;</span>;<br></code></pre></td></tr></table></figure></li><li>DB_SCHEMA_UPDATE_FALSE &#x3D; “false”<br>含义：不自动更新数据库模式。即，应用程序启动时，数据库模式不会发生任何改变。如果数据库中表结构与实体类（或模型）不一致，应用程序将抛出异常，要求手动处理。<br>使用场景：适用于生产环境，避免在启动时自动修改数据库结构，确保数据库的稳定性。</li><li>DB_SCHEMA_UPDATE_CREATE &#x3D; “create”<br>含义：每次应用启动时，都会根据实体类创建新的数据库表。通常会删除现有的表并重新创建。这意味着如果表已经存在，它们将被删除并重新创建（不会保留数据）。<br>使用场景：适用于开发环境或者首次部署时，用于生成表结构。如果不关心数据丢失，可以使用这个选项。</li><li>DB_SCHEMA_UPDATE_CREATE_DROP &#x3D; “create-drop”<br>含义：在应用启动时创建数据库表，在应用停止时删除数据库表。这个选项会在应用的生命周期内创建表，但在应用停止时会删除表，因此适合用于开发、测试或临时环境。<br>使用场景：适用于测试和开发环境，当你不需要持久存储数据库数据时。</li><li>DB_SCHEMA_UPDATE_DROP_CREATE &#x3D; “drop-create”<br>含义：在应用启动时删除现有的数据库表，并根据实体类重新创建表。不同于 create-drop，这个选项不会在应用停止时删除表。它只会在应用启动时删除和创建表，但不影响应用的生命周期。<br>使用场景：适用于开发过程中，当你希望每次启动时都从头开始，重建表结构，但不希望在应用停止时丢失表。</li></ol><h2 id="定义一个审核流程"><a href="#定义一个审核流程" class="headerlink" title="定义一个审核流程"></a>定义一个审核流程</h2><p>如图，通常审核流程包括如下结构，开始节点、结束节点和中间具体执行人的节点，另外有一些形式的审核流程不包括申请人的环节，直接绘制审核流程，通常情况下包含申请人更加合理。并且二者的在操作上并无太大差异，具体可以在了解flowable的工作原理后自行辨别。</p><img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219184152466.png" title="hh"/><p>如下是对应的xml文件的关键信息，其中包括流程id,流程名称，流程分类,这里还可以定义流程描述和其他的属性信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">process</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;flow_z81n3ymf&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;测试流程1&quot;</span> <span class="hljs-attr">flowable:processCategory</span>=<span class="hljs-string">&quot;type1&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">documentation</span>&gt;</span>测试流程1.<span class="hljs-tag">&lt;/<span class="hljs-name">documentation</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">extensionElements</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">flowable:properties</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">flowable:property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;expro1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;value1&quot;</span> /&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">flowable:property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;expro2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;value2&quot;</span> /&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">flowable:properties</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">extensionElements</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">startEvent</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;start_event&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;开始&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">outgoing</span>&gt;</span>Flow_03y5jhz<span class="hljs-tag">&lt;/<span class="hljs-name">outgoing</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">startEvent</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">userTask</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Activity_0egx7q1&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;申请人&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">incoming</span>&gt;</span>Flow_03y5jhz<span class="hljs-tag">&lt;/<span class="hljs-name">incoming</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">outgoing</span>&gt;</span>Flow_1wluipz<span class="hljs-tag">&lt;/<span class="hljs-name">outgoing</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">userTask</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">userTask</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Activity_0ovnvli&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;一级处理人&quot;</span> <span class="hljs-attr">flowable:assignee</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">flowable:userType</span>=<span class="hljs-string">&quot;assignee&quot;</span> <span class="hljs-attr">flowable:dataType</span>=<span class="hljs-string">&quot;fixed&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">incoming</span>&gt;</span>Flow_1wluipz<span class="hljs-tag">&lt;/<span class="hljs-name">incoming</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">outgoing</span>&gt;</span>Flow_1gldaiz<span class="hljs-tag">&lt;/<span class="hljs-name">outgoing</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">userTask</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">userTask</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Activity_11blnld&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;二级处理人&quot;</span> <span class="hljs-attr">flowable:assignee</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">flowable:userType</span>=<span class="hljs-string">&quot;assignee&quot;</span> <span class="hljs-attr">flowable:dataType</span>=<span class="hljs-string">&quot;fixed&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">extensionElements</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">flowable:properties</span> /&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">extensionElements</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">incoming</span>&gt;</span>Flow_1gldaiz<span class="hljs-tag">&lt;/<span class="hljs-name">incoming</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">outgoing</span>&gt;</span>Flow_08pelnj<span class="hljs-tag">&lt;/<span class="hljs-name">outgoing</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">userTask</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">endEvent</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Event_07og00d&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;结束&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">incoming</span>&gt;</span>Flow_08pelnj<span class="hljs-tag">&lt;/<span class="hljs-name">incoming</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">endEvent</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Flow_03y5jhz&quot;</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">&quot;start_event&quot;</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">&quot;Activity_0egx7q1&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Flow_1wluipz&quot;</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">&quot;Activity_0egx7q1&quot;</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">&quot;Activity_0ovnvli&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Flow_1gldaiz&quot;</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">&quot;Activity_0ovnvli&quot;</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">&quot;Activity_11blnld&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Flow_08pelnj&quot;</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">&quot;Activity_11blnld&quot;</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">&quot;Event_07og00d&quot;</span> /&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">process</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="部署一个审核流程"><a href="#部署一个审核流程" class="headerlink" title="部署一个审核流程"></a>部署一个审核流程</h2><p>下面通过部署上文中的xml形式定义的审核流程，了解flowable中涉及到的表以及对应的关系</p><ol><li>流程部署代码<br>流程部署通过repositoryService进行，使用流程引擎processEngine获得。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">      <span class="hljs-comment">// 部署流程 获取RepositoryService对象</span><br>      <span class="hljs-type">RepositoryService</span> <span class="hljs-variable">repositoryService</span> <span class="hljs-operator">=</span> processEngine.getRepositoryService();<br>      <span class="hljs-type">Deployment</span> <span class="hljs-variable">deployment</span> <span class="hljs-operator">=</span> repositoryService.createDeployment()<span class="hljs-comment">// 创建Deployment对象</span><br>              .addClasspathResource(<span class="hljs-string">&quot;测试流程1.bpmn20.xml&quot;</span>) <span class="hljs-comment">// 添加流程部署文件</span><br>              .name(<span class="hljs-string">&quot;部署名称&quot;</span>)<br>              .category(<span class="hljs-string">&quot;部署分类&quot;</span>)<br>              .deploy(); <span class="hljs-comment">// 执行部署操作</span><br><span class="hljs-comment">//设置流程定义类别</span><br><span class="hljs-type">ProcessDefinition</span> <span class="hljs-variable">definition</span> <span class="hljs-operator">=</span> repositoryService.createProcessDefinitionQuery().deploymentId(deployment.getId()).singleResult();<br>repositoryService.setProcessDefinitionCategory(definition.getId(), <span class="hljs-string">&quot;type1&quot;</span>);<br><br></code></pre></td></tr></table></figure></li><li>流程部署具体过程<br>通过查看相关日志，有如下信息。说明在部署时会插入四个对象，这里的对象id已经确定，所以后面再插入的时候可以先插入流程实例，再插入流程部署</li></ol><img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219184334290.png" title="hh"/>下面根据日志中的insert语句分析具体流程+ 首先，在ACT_RE_PROCDEF表插入流程定义相关数据，xml中的id，name,documentation(数据库中的DESCRIPTION_)都有对应字段，但CATEGORY_是默认分类，说明flowable:processCategory并不能直接映射到数据库中，可以通过API进行设置。<img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219184746423.png"/>ACT_RE_PROCDEF表结构如下，SUSPENSION_STATE_中1表示部署，2表示挂起。<img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219184814319.png"/>+ 其次在ACT_RE_DEPLOYMENT表插入流程部署相关信息<img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219184907390.png"/><img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219184932684.png"/>+ 在ACT_GE_BYTEARRAY中插入部署流程的xml文件的byte数据，包括xml文件和图片形式的文件<img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219185023350.png"/><img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219185048321.png"/>总结：流程部署时涉及三个表，其中部署表是最主要的表，流程定义表中关联部署表，并且流程信息的文件表也通过部署ID进行关联。## 查看审核流程有了上述分析，查看审核流程就很简单了，只是对上述表进行相关查询，可以自己实现，当然最好是使用flowable中的API进行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//查询流程定义表</span><br><span class="hljs-type">ProcessDefinition</span> <span class="hljs-variable">processDefinition</span> <span class="hljs-operator">=</span> repositoryService.createProcessDefinitionQuery()<br>                .deploymentId(<span class="hljs-string">&quot;1&quot;</span>)<br>                .singleResult();<br><span class="hljs-comment">//查询流程部署表</span><br><span class="hljs-type">Deployment</span> <span class="hljs-variable">deployment</span> <span class="hljs-operator">=</span> repositoryService.createDeploymentQuery().deploymentId(<span class="hljs-string">&quot;1&quot;</span>).singleResult();<br><span class="hljs-comment">//查询资源表，根据资源名称区分xml文件和图片文件</span><br><span class="hljs-type">InputStream</span> <span class="hljs-variable">xml</span> <span class="hljs-operator">=</span> repositoryService.getResourceAsStream(processDefinition.getDeploymentId(), processDefinition.getResourceName());<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">png</span> <span class="hljs-operator">=</span> repositoryService.getResourceAsStream(processDefinition.getDeploymentId(), processDefinition.getDiagramResourceName());  <br></code></pre></td></tr></table></figure>上述只能获取图片的二进制流，flowable提供了更加便捷的方式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ProcessDefinition</span> <span class="hljs-variable">processDefinition</span> <span class="hljs-operator">=</span> repositoryService.createProcessDefinitionQuery().deploymentId(deployId).singleResult();<br><span class="hljs-comment">//获得图片流</span><br><span class="hljs-type">DefaultProcessDiagramGenerator</span> <span class="hljs-variable">diagramGenerator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultProcessDiagramGenerator</span>();<br><span class="hljs-type">BpmnModel</span> <span class="hljs-variable">bpmnModel</span> <span class="hljs-operator">=</span> repositoryService.getBpmnModel(processDefinition.getId());<br><span class="hljs-comment">//输出为图片</span><br><span class="hljs-keyword">return</span> diagramGenerator.generateDiagram(<br>bpmnModel,<br><span class="hljs-string">&quot;png&quot;</span>,<br>Collections.emptyList(),<br>Collections.emptyList(),<br><span class="hljs-string">&quot;宋体&quot;</span>,<br><span class="hljs-string">&quot;宋体&quot;</span>,<br><span class="hljs-string">&quot;宋体&quot;</span>,<br><span class="hljs-literal">null</span>,<br><span class="hljs-number">1.0</span>,<br><span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure>## 启动流程实例启动流程实例需要使用runtimeService，样例代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//启动前可以设置流程启动的用户id</span><br>identityService.setAuthenticatedUserId(sysUser.getUserId().toString());<br><span class="hljs-comment">// 启动流程实例通过 RuntimeService 对象</span><br><span class="hljs-type">RuntimeService</span> <span class="hljs-variable">runtimeService</span> <span class="hljs-operator">=</span> processEngine.getRuntimeService();<br><span class="hljs-comment">// 构建流程变量</span><br>Map&lt;String,Object&gt; variables = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>variables.put(<span class="hljs-string">&quot;employee&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>) ;<span class="hljs-comment">// 谁申请请假</span><br>variables.put(<span class="hljs-string">&quot;nrOfHolidays&quot;</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">// 请几天假</span><br>variables.put(<span class="hljs-string">&quot;description&quot;</span>,<span class="hljs-string">&quot;工作累了，想出去玩玩&quot;</span>); <span class="hljs-comment">// 请假的原因</span><br><span class="hljs-comment">// 启动流程实例，第一个参数是流程定义的id</span><br><span class="hljs-type">ProcessInstance</span> <span class="hljs-variable">processInstance</span> <span class="hljs-operator">=</span> runtimeService<br>.startProcessInstanceByKey(<span class="hljs-string">&quot;flow_z81n3ymf&quot;</span>, variables);<span class="hljs-comment">// 启动流程实例</span><br><span class="hljs-comment">// 输出相关的流程实例信息</span><br>System.out.println(<span class="hljs-string">&quot;流程定义的ID：&quot;</span> + processInstance.getProcessDefinitionId());<br>System.out.println(<span class="hljs-string">&quot;流程实例的ID：&quot;</span> + processInstance.getId());<br>System.out.println(<span class="hljs-string">&quot;当前活动的ID：&quot;</span> + processInstance.getActivityId());<br></code></pre></td></tr></table></figure>上述代码很简单，下面分析下具体执行过程。在启动流程实例时，传入了涉及的参数，如在请假流程中的申请人、请假天数和理由，实际上可以传递任意参数，如果不想直接传入或业务有其他要求，可以另外新建申请表，才启动流程实例时传入申请表中记录的id即可，在需要信息时再根据记录id去查询记录。启动流程实例涉及如下表插入操作<img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219185112395.png"/>启动流程实例时，涉及到流程实例表和历史流程实例表两个插入传入参数，涉及到参数表和历史参数表的插入，几条参数几个插入流程从start圆圈开始启动，并进入第一个方块，涉及到两个历史活跃实例，分别是start圆圈的和第一个方块的流程启动后，到第一个方块，会产生一个任务，涉及一个任务的插入流程启动后，需要一个执行实例，涉及到执行实例的插入<ol><li>具体操作中先向ACT_HI_VARINST表插入传递的数据，三条数据一起插入。<img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219185550913.png"/></li></ol><p>这是对应的表结构，主要包括流程实例ID，执行实例ID,任务实例ID,当前是流程实例的数据，因此任务ID为空<br><img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219185615373.png"/></p><ol start="2"><li>向ACT_HI_TASKINST插入任务信息<img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219185639858.png"/></li></ol><p>关键信息包括流程定义ID,流程实例ID,执行实例ID,任务定义KEY等信息，还有业务相关信息，如办理人、开始时间、认领时间，在对任务进行操作时，任务历史信息都会跟着改变。<br><img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219185708202.png"/></p><ol start="3"><li>历史流程实例插入<img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219185727609.png"/></li></ol><img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219185743109.png"/><ol start="4"><li>然后是历史活动的节点表<img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219185824710.png"/></li></ol><p>包括流程实例ID,执行实例ID等<br><img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219185847223.png"/></p><ol start="5"><li><p>执行实例插入act_ru_execution，<br>ACT_RU_EXECUTION表即运行时流程执行实例表。该表主要用于存储流程运行时的执行实例。流程启动时，会生成一个流程实例，以及相应的执行实例，流程实例和执行实例都存储在ACT_RU_EXECUTION表中。因此实行了两条插入。执行实例有个字段PARENT_ID_指向流程实例</p><img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219185904585.png"/></li><li><p>运行任务的插入</p><img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219185920949.png"/></li></ol><img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219185936011.png"/><ol start="7"><li>运行时数据插入 同历史数据插入<img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219185957447.png"/></li></ol><p>总结，启动一个任务涉及到上述7张表的操作，需要注意的是历史实例表是单独一张表，流程实例和流程执行在一张流程执行表中，开启一个流程实例会在流程实例表添加两条数据，流程执行的PARENT_ID_指向流程实例。</p><h2 id="查看我的待执行的任务"><a href="#查看我的待执行的任务" class="headerlink" title="查看我的待执行的任务"></a>查看我的待执行的任务</h2><p>流程已经启动了，卡在申请人的步骤，现在申请人需要查看他的任务，并进行相关处理。在我们这里，并没有指定申请人的任务执行人，一般来说启动一个流程实例时，同时会把申请人的环节执行掉，现在我们使用部署id来获得这个任务，通常是使用候选人或候选组进行查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">TaskService</span> <span class="hljs-variable">taskService</span> <span class="hljs-operator">=</span> processEngine.getTaskService();<br><span class="hljs-type">Task</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> taskService.createTaskQuery().deploymentId(<span class="hljs-string">&quot;1&quot;</span>).singleResult();<br>System.out.println(<span class="hljs-string">&quot;task.getProcessDefinitionId() = &quot;</span> + task.getProcessDefinitionId());<br>System.out.println(<span class="hljs-string">&quot;task.getId() = &quot;</span> + task.getId());<br>System.out.println(<span class="hljs-string">&quot;task.getAssignee() = &quot;</span> + task.getAssignee());<br>System.out.println(<span class="hljs-string">&quot;task.getName() = &quot;</span> + task.getName());<br>HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>);<br><span class="hljs-comment">//taskService.addComment()审核时还可以添加评论</span><br>taskService.complete(task.getId(),map);<br></code></pre></td></tr></table></figure><p>涉及到8个插入，3个更新，1个删除<br><img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219190039672.png"/></p><p>完成后进入下一个方块，即插入新的任务，活跃节点，同时插入到历史任务，还有方块对应的历史活跃节点，更新执行实例的活跃节点到这个方块，删除执行完的任务，更新历史中这个任务和活跃节点的完成时间完成人等信息。<br>3插3更1删<br>添加了一条数据，涉及到数据和历史数据插入，这里的数据还是属于流程实例的，不是任务的，因此表中任务id为空。<br>2插<br>ACT_HI_IDENTITYLINK表即历史流程与身份关系表，其字段如下表所示。该表主要用于存储历史流程实例、任务实例与参与者之间的关联关系。<br><img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219190018948.png"/><br>记录执行完的任务的执行人信息，和流程的参与人信息。<br>一个任务执行后会在历史表中记录执行人信息对应任务ID，和执行人信息对应执行实例<br>一个任务完成执行，在act_ru_identitylink中会存放执行人对应执行实例的记录<br>（这个就是记录执行人相关信息，在task中一般都有执行人，这个表的作用我暂时还不知道）<br>3插</p><h2 id="继续执行任务"><a href="#继续执行任务" class="headerlink" title="继续执行任务"></a>继续执行任务</h2><p>当前任务到了一级审核人，对应id为1，因此可以通过这个查询到任务，并执行。</p><p><strong>最基本的操作就到这里，涉及到了关键的几张表，以及一些我觉得会忽略的细节，可以搭配贺波的深入Activit流程引擎以及flowable的官方文档<a href="https://www.flowable.com/open-source/docs/">https://www.flowable.com/open-source/docs/</a> 进行理解。上文如有错误，欢迎指正，谢谢。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>flowable</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Exception相关知识总结</title>
    <link href="/2025/01/10/Java%20Exception%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <url>/2025/01/10/Java%20Exception%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Java-Exception相关知识总结"><a href="#Java-Exception相关知识总结" class="headerlink" title="Java Exception相关知识总结"></a>Java Exception相关知识总结</h1><p>首先引入一个JavaGuide的Java异常类层次结构图概览</p><h2 id="Exception和Error的区别"><a href="#Exception和Error的区别" class="headerlink" title="Exception和Error的区别"></a>Exception和Error的区别</h2><p>根据结构图Exception和Error都是继承自Throwable</p><ul><li>Exception是异常，指定是程序本身的异常，分为Checked Exception和Unchecked Exception<ul><li>Checked Exception即受检查异常，指的是需要进行检查，如catch或throws处理，不然不会编译通过。</li><li>Unchecked Exception即不受检查异常，不需要处理也可以正常编译。</li></ul></li><li>error是程序无法处理的错误，通常来说是虚拟机的错误，可以结合虚拟机的组成去思考，包括虚拟机堆内存溢出，栈内存溢出，虚拟机运行错误等。</li></ul><h2 id="常见的Checked-Exception"><a href="#常见的Checked-Exception" class="headerlink" title="常见的Checked Exception"></a>常见的Checked Exception</h2><p>除了RuntimeException及其子类外，其他Exception类及其子类都属于受检查异常。常见的包括IO相关的，数据库相关的异常。</p><ul><li><p>编码异常UnsupportedEncodingException</p><img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219181821666.png" title="hh"/></li><li><p>文件异常FileNotFoundException</p><img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219182030186.png" title="hh"/></li><li><p>IO操作异常IOException</p><img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219182226721.png" title="hh"/></li><li><p>数据库异常SQLException</p><img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219182614258.png" title="hh"/></li></ul><h2 id="常见的Unchecked-Exception"><a href="#常见的Unchecked-Exception" class="headerlink" title="常见的Unchecked Exception"></a>常见的Unchecked Exception</h2><ul><li>NullPointerException 空指针异常</li></ul><img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219182445575.png" title="hh"/><ul><li><p>ArithmeticException 算数异常</p><img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219182703489.png" title="hh"/></li><li><p>ClassCastException类型转换异常</p></li></ul><img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219183222229.png" title="hh"/><ul><li>ArrayIndexOutOfBoundsException 数组越界异常</li></ul><img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219182956485.png" title="hh"/><ul><li><p>NumberFormatException 字符串转换数值异常</p><img src="https://cdn.jsdelivr.net/gh/XiaovvDe/my_pic_upload/imgs/20250219183128603.png" title="hh"/></li><li><p>此外，自己实现的继承RuntimeException的统一异常类</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flowable学习笔记-若依框架</title>
    <link href="/2024/12/26/flowable%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E8%8B%A5%E4%BE%9D%E6%A1%86%E6%9E%B6/"/>
    <url>/2024/12/26/flowable%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02-%E8%8B%A5%E4%BE%9D%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="flowable学习笔记-若依框架"><a href="#flowable学习笔记-若依框架" class="headerlink" title="flowable学习笔记-若依框架"></a>flowable学习笔记-若依框架</h1><h2 id="添加流程"><a href="#添加流程" class="headerlink" title="添加流程"></a>添加流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 导入流程文件</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 当每个key的流程第一次部署时，指定版本为1。对其后所有使用相同key的流程定义，</span><br><span class="hljs-comment">     * 部署时版本会在该key当前已部署的最高版本号基础上加1。key参数用于区分流程定义</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name  流程名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> category 流程分类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> in xml字节流</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">importFile</span><span class="hljs-params">(String name, String category, InputStream in)</span> &#123;<br>        <span class="hljs-comment">// 创建并部署流程  输入xml文件的bit流并设置部署表中的name和分类</span><br>        <span class="hljs-type">Deployment</span> <span class="hljs-variable">deploy</span> <span class="hljs-operator">=</span> repositoryService.createDeployment().addInputStream(name + BPMN_FILE_SUFFIX, in)<br>                .name(name)<br>                .category(category)<br>                .deploy();<br>        <span class="hljs-comment">// 部署后根据部署的id获取流程定义，设置流程定义的分类</span><br>        <span class="hljs-type">ProcessDefinition</span> <span class="hljs-variable">definition</span> <span class="hljs-operator">=</span> repositoryService.createProcessDefinitionQuery().deploymentId(deploy.getId()).singleResult();<br>        repositoryService.setProcessDefinitionCategory(definition.getId(), category);<br><br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="流程定义分页查询"><a href="#流程定义分页查询" class="headerlink" title="流程定义分页查询"></a>流程定义分页查询</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 流程定义列表</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name  流程名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pageNum  当前页码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pageSize 每页条数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 流程定义分页列表数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Page&lt;FlowProcDefDto&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(String name, Integer pageNum, Integer pageSize)</span> &#123;<br>        Page&lt;FlowProcDefDto&gt; page = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;();<br>        PageHelper.startPage(pageNum, pageSize);<br>        <span class="hljs-comment">// 这里自己写sql,在部署表中查</span><br>        <span class="hljs-keyword">final</span> List&lt;FlowProcDefDto&gt; dataList = flowDeployMapper.selectDeployList(name);<br><span class="hljs-comment">//        final List&lt;EchainFlowInfo&gt; dataList  = echainFlowInfoMapper.selectByProdefName(name);</span><br>        page.setTotal(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PageInfo</span>(dataList).getTotal());<br>        page.setRecords(dataList);<br>        <span class="hljs-keyword">return</span> page;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectDeployList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.ruoyi.system.domain.FlowProcDefDto&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 可以看到就是连表查询，涉及到流程定义表和流程部署表 --&gt;</span><br>        SELECT<br>            rp.id_ as id,<br>            rp.deployment_id_ as deploymentId,<br>            rd.name_ as name,<br>            rd.category_ as category,<br>            rp.key_ as flowKey,<br>            rp.version_ as version,<br>            rp.suspension_state_ as suspensionState,<br>            rd.deploy_time_  as deploymentTime<br>        FROM<br>            act_re_procdef rp<br>                LEFT JOIN act_re_deployment rd ON rp.deployment_id_ = rd.id_<br>        <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null and name != &#x27;&#x27;&quot;</span>&gt;</span><br>               and rd.name_ like concat(&#x27;%&#x27;, #&#123;name&#125;, &#x27;%&#x27;)<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br>        order by rd.deploy_time_ desc<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="读取流程xml"><a href="#读取流程xml" class="headerlink" title="读取流程xml"></a>读取流程xml</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 读取xml</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> deployId 流程部署Id</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> AjaxResult <span class="hljs-title function_">readXml</span><span class="hljs-params">(String deployId)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//首先根据部署id获取最新版本的流程定义</span><br>        <span class="hljs-type">ProcessDefinition</span> <span class="hljs-variable">definition</span> <span class="hljs-operator">=</span> repositoryService.createProcessDefinitionQuery().deploymentId(deployId).singleResult();<br>        <span class="hljs-comment">//根据流程部署id和流程资源名称获取xml字节流，涉及到的就是act_ge_bytearray表</span><br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> repositoryService.getResourceAsStream(definition.getDeploymentId(), definition.getResourceName());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> IOUtils.toString(inputStream, StandardCharsets.UTF_8.name());<br>        <span class="hljs-keyword">return</span> AjaxResult.success(<span class="hljs-string">&quot;&quot;</span>, result);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="获取流程实例执行情况"><a href="#获取流程实例执行情况" class="headerlink" title="获取流程实例执行情况"></a>获取流程实例执行情况</h2><p>使用历史活跃节点查询完成或正在活跃的节点，配合xml返回给前端显示<br>9814</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 流程节点信息</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> procInsId</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> AjaxResult <span class="hljs-title function_">flowXmlAndNode</span><span class="hljs-params">(String procInsId, String deployId)</span> &#123;<br>       <span class="hljs-keyword">try</span> &#123;<br>           List&lt;FlowViewerDto&gt; flowViewerList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>           <span class="hljs-comment">// 获取已经完成的节点</span><br>           List&lt;HistoricActivityInstance&gt; listFinished = historyService.createHistoricActivityInstanceQuery()<br>                   .processInstanceId(procInsId)<br>                   .finished()<br>                   .list();<br><br>           <span class="hljs-comment">// 保存已经完成的流程节点编号</span><br>           listFinished.forEach(s -&gt; &#123;<br>               <span class="hljs-type">FlowViewerDto</span> <span class="hljs-variable">flowViewerDto</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowViewerDto</span>();<br>               flowViewerDto.setKey(s.getActivityId());<br>               flowViewerDto.setCompleted(<span class="hljs-literal">true</span>);<br>               <span class="hljs-comment">// 退回节点不进行展示</span><br>               <span class="hljs-keyword">if</span> (StringUtils.isBlank(s.getDeleteReason())) &#123;<br>                   flowViewerList.add(flowViewerDto);<br>               &#125;<br>           &#125;);<br><br>           <span class="hljs-comment">// 获取代办节点</span><br>           List&lt;HistoricActivityInstance&gt; listUnFinished = historyService.createHistoricActivityInstanceQuery()<br>                   .processInstanceId(procInsId)<br>                   .unfinished()<br>                   .list();<br><br>           <span class="hljs-comment">// 保存需要代办的节点编号</span><br>           listUnFinished.forEach(s -&gt; &#123;<br>               <span class="hljs-comment">// 删除已退回节点</span><br>               flowViewerList.removeIf(task -&gt; task.getKey().equals(s.getActivityId()));<br>               <span class="hljs-type">FlowViewerDto</span> <span class="hljs-variable">flowViewerDto</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowViewerDto</span>();<br>               flowViewerDto.setKey(s.getActivityId());<br>               flowViewerDto.setCompleted(<span class="hljs-literal">false</span>);<br>               flowViewerList.add(flowViewerDto);<br>           &#125;);<br>           Map&lt;String, Object&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>           <span class="hljs-comment">// xmlData 数据</span><br>           <span class="hljs-type">ProcessDefinition</span> <span class="hljs-variable">definition</span> <span class="hljs-operator">=</span> repositoryService.createProcessDefinitionQuery().deploymentId(deployId).singleResult();<br>           <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> repositoryService.getResourceAsStream(definition.getDeploymentId(), definition.getResourceName());<br>           <span class="hljs-type">String</span> <span class="hljs-variable">xmlData</span> <span class="hljs-operator">=</span> IOUtils.toString(inputStream, StandardCharsets.UTF_8);<br>           result.put(<span class="hljs-string">&quot;nodeData&quot;</span>, flowViewerList);<br>           result.put(<span class="hljs-string">&quot;xmlData&quot;</span>, xmlData);<br>           <span class="hljs-keyword">return</span> AjaxResult.success(result);<br>       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>           <span class="hljs-keyword">return</span> AjaxResult.error(<span class="hljs-string">&quot;高亮历史任务失败&quot;</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="任务完成"><a href="#任务完成" class="headerlink" title="任务完成"></a>任务完成</h2><p>分两种情况，有可能是委派任务，简单区分即可。<br>DelegationState 是一个枚举，定义了任务委派的几种状态。它包括以下几种状态：<br>PENDING：任务处于待委派状态。<br>表示任务已经被委派，但尚未完成委派操作。任务当前由原来的负责人（assignee）持有，但此任务的处理被推迟给了新的任务负责人。<br>RESOLVED：任务委派已解决。<br>表示任务已经被委派且已完成。任务已成功转交给新负责人，并且委派已完成。当前的负责人是新委派的用户。<br>NONE：任务未被委派。<br>表示该任务没有委派，仍然由原始的任务负责人处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 完成任务</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> taskVo 请求实体参数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> AjaxResult <span class="hljs-title function_">complete</span><span class="hljs-params">(FlowTaskVo taskVo)</span> &#123;<br>    <span class="hljs-type">Task</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> taskService.createTaskQuery().taskId(taskVo.getTaskId()).singleResult();<br>    <span class="hljs-keyword">if</span> (Objects.isNull(task)) &#123;<br>        <span class="hljs-keyword">return</span> AjaxResult.error(<span class="hljs-string">&quot;任务不存在&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (DelegationState.PENDING.equals(task.getDelegationState())) &#123;<br>        taskService.addComment(taskVo.getTaskId(), taskVo.getInstanceId(), FlowComment.DELEGATE.getType(), taskVo.getComment());<br>        taskService.resolveTask(taskVo.getTaskId(), taskVo.getVariables());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        taskService.addComment(taskVo.getTaskId(), taskVo.getInstanceId(), FlowComment.NORMAL.getType(), taskVo.getComment());<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> SecurityUtils.getLoginUser().getUser().getUserId();<br>        taskService.setAssignee(taskVo.getTaskId(), userId.toString());<br>        taskService.complete(taskVo.getTaskId(), taskVo.getVariables());<br>    &#125;<br>    <span class="hljs-keyword">return</span> AjaxResult.success();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>flowable</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2024/09/28/Spring%20Security%20%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83(%E9%BB%91%E9%A9%AC%E8%AE%B2%E4%B9%89)%20/"/>
    <url>/2024/09/28/Spring%20Security%20%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83(%E9%BB%91%E9%A9%AC%E8%AE%B2%E4%B9%89)%20/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h1><h2 id="1-1-什么是认证"><a href="#1-1-什么是认证" class="headerlink" title="1.1.什么是认证"></a>1.1.什么是认证</h2><p>用户认证就是判断一个用户的身份是否合法的过程，用户去访问系统资源时系统要求验证用户的身份信息，身份合法方可继续访问，不合法则拒绝访问。常见的用户身份认证方式有：用户名密码登录，二维码登录，手机短信登录，指纹认证等方式。</p><h2 id="1-2-什么是授权"><a href="#1-2-什么是授权" class="headerlink" title="1.2.什么是授权"></a>1.2.什么是授权</h2><p>认证是为了保证用户身份的合法性，授权则是为了更细粒度的对隐私数据进行划分，授权是在认证通过后发生的，控制不同的用户能够访问不同的资源。<br>授权是用户认证通过根据用户的权限来控制用户访问资源的过程，拥有资源的访问权限则正常访问，没有 权限则拒绝访问。</p><h2 id="1-3-授权的数据模型"><a href="#1-3-授权的数据模型" class="headerlink" title="1.3.授权的数据模型"></a>1.3.授权的数据模型</h2><p>授权可简单理解为Who对What(which)进行How操作，包括如下：<br>Who，即主体（Subject），主体一般是指用户，也可以是程序，需要访问系统中的资源。<br>What，即资源 （Resource），如系统菜单、页面、按钮、代码方法、系统商品信息、系统订单信息等。系统菜单、页面、按 钮、代码方法都属于系统功能资源，对于web系统每个功能资源通常对应一个URL；系统商品信息、系统订单信息 都属于实体资源（数据资源），实体资源由资源类型和资源实例组成，比如商品信息为资源类型，商品编号 为001 的商品为资源实例。<br>How，权限&#x2F;许可（Permission），规定了用户对资源的操作许可，权限离开资源没有意义， 如用户查询权限、用户添加权限、某个代码方法的调用权限、编号为001的用户的修改权限等，通过权限可知用户 对哪些资源都有哪些操作许可。<br>主体、资源、权限关系如下图：<br>677<br>修改后数据模型之间的关系如下图：<br>791</p><h2 id="1-4-RBAC"><a href="#1-4-RBAC" class="headerlink" title="1.4 RBAC"></a>1.4 RBAC</h2><p>如何实现授权？业界通常基于RBAC实现授权。</p><h3 id="1-4-1-基于角色的访问控制"><a href="#1-4-1-基于角色的访问控制" class="headerlink" title="1.4.1 基于角色的访问控制"></a>1.4.1 基于角色的访问控制</h3><p>RBAC基于角色的访问控制（Role-Based Access Control）是按角色进行授权，<br>比如：主体的角色为总经理可以查 询企业运营报表，查询员工工资信息等，访问控制流程如下:<br>1037<br>根据上图中的判断逻辑，授权代码可表示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(主体.hasRole(<span class="hljs-string">&quot;总经理角色id&quot;</span>))&#123; <br>查询工资 <br>&#125;<br></code></pre></td></tr></table></figure><p>如果上图中查询工资所需要的角色变化为总经理和部门经理，此时就需要修改判断逻辑为“判断用户的角色是否是 总经理或部门经理”，修改代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(主体.hasRole(<span class="hljs-string">&quot;总经理角色id&quot;</span>) || 主体.hasRole(<span class="hljs-string">&quot;部门经理角色id&quot;</span>))&#123; <br>查询工资 <br>&#125;<br></code></pre></td></tr></table></figure><p>上边的例子发现，当需要修改角色的权限时就需要修改授权的相关代码，系统可扩展性差。</p><h3 id="1-4-2-基于资源的访问控制"><a href="#1-4-2-基于资源的访问控制" class="headerlink" title="1.4.2 基于资源的访问控制"></a>1.4.2 基于资源的访问控制</h3><p>RBAC基于资源的访问控制（Resource-Based Access Control）是按资源（或权限）进行授权，<br>比如：用户必须 具有查询工资权限才可以查询员工工资信息等，访问控制流程如下：<br>2335<br>根据上图中的判断，授权代码可以表示为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(主体.hasPermission(<span class="hljs-string">&quot;查询工资权限标识&quot;</span>))&#123;<br>查询工资 <br>&#125;<br></code></pre></td></tr></table></figure><p>优点：系统设计时定义好查询工资的权限标识，即使查询工资所需要的角色变化为总经理和部门经理也不需要修改 授权代码，系统可扩展性强。</p><h1 id="基于Session的认证方式"><a href="#基于Session的认证方式" class="headerlink" title="基于Session的认证方式"></a>基于Session的认证方式</h1><h2 id="2-1-认证流程"><a href="#2-1-认证流程" class="headerlink" title="2.1 认证流程"></a>2.1 认证流程</h2><p>基于Session认证方式的流程是，用户认证成功后，在服务端生成用户相关的数据保存在session(当前会话)，而发 给客户端的 sesssion_id 存放到 cookie 中，这样用客户端请求时带上 session_id 就可以验证服务器端是否存在 session 数据，以此完成用户的合法校验。当用户退出系统或session过期销毁时,客户端的session_id也就无效了。<br>基于Session的认证机制由Servlet规范定制，Servlet容器已实现，用户通过HttpSession的操作方法即可实现，如 下是HttpSession相关的操作API。</p><table><thead><tr><th>方法</th><th>含义</th></tr></thead><tbody><tr><td>HttpSession getSession(Boolean create)</td><td>获取当前HttpSession对象</td></tr><tr><td>void setAttribute(String name,Object value)</td><td>向session中存放对象</td></tr><tr><td>object getAttribute(String name)</td><td>从session中获取对象</td></tr><tr><td>void removeAttribute(String name);</td><td>移除session中对象</td></tr><tr><td>void invalidate()</td><td>使HttpSession失效</td></tr></tbody></table><p><strong>主要代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/login&quot;,produces = &quot;text/plain;charset=utf-8&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">(AuthenticationRequest authenticationRequest, HttpSession session)</span>&#123;<br><span class="hljs-comment">//数据库查询用户信息，以及权限信息</span><br>        <span class="hljs-type">UserDto</span> <span class="hljs-variable">userDto</span> <span class="hljs-operator">=</span> authenticationService.authentication(authenticationRequest);<br>        <span class="hljs-comment">//存入session</span><br>        session.setAttribute(UserDto.SESSION_USER_KEY,userDto);<br>        <span class="hljs-keyword">return</span> userDto.getUsername() +<span class="hljs-string">&quot;登录成功&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//在这个方法中校验用户请求的url是否在用户的权限范围内</span><br>        <span class="hljs-comment">//取出用户身份信息</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> request.getSession().getAttribute(UserDto.SESSION_USER_KEY);<br>        <span class="hljs-keyword">if</span>(object == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//没有认证，提示登录</span><br>            writeContent(response,<span class="hljs-string">&quot;请登录&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">UserDto</span> <span class="hljs-variable">userDto</span> <span class="hljs-operator">=</span> (UserDto) object;<br>        <span class="hljs-comment">//请求的url</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">requestURI</span> <span class="hljs-operator">=</span> request.getRequestURI();<br>        <span class="hljs-keyword">if</span>( userDto.getAuthorities().contains(<span class="hljs-string">&quot;p1&quot;</span>) &amp;&amp; requestURI.contains(<span class="hljs-string">&quot;/r/r1&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>( userDto.getAuthorities().contains(<span class="hljs-string">&quot;p2&quot;</span>) &amp;&amp; requestURI.contains(<span class="hljs-string">&quot;/r/r2&quot;</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        writeContent(response,<span class="hljs-string">&quot;没有权限，拒绝访问&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="3-Spring-Security"><a href="#3-Spring-Security" class="headerlink" title="3.Spring Security"></a>3.Spring Security</h1><h2 id="3-1-Spring-Security介绍"><a href="#3-1-Spring-Security介绍" class="headerlink" title="3.1 Spring Security介绍"></a>3.1 Spring Security介绍</h2><p>Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。由于它 是Spring生态系统中的一员，因此它伴随着整个Spring生态系统不断修正、升级，在spring boot项目中加入spring security更是十分简单，使用Spring Security 减少了为企业系统安全控制编写大量重复代码的工作。<br><strong>主要代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableWebSecurity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebSecurityConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebSecurityConfigurerAdapter</span> &#123;<br>    <span class="hljs-comment">//密码编码器</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title function_">passwordEncoder</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> NoOpPasswordEncoder.getInstance();<br>    &#125;<br><br>    <span class="hljs-comment">//安全拦截机制（最重要）web端配置，还可以通过注解实现方法端控制</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configure</span><span class="hljs-params">(HttpSecurity http)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        http.authorizeRequests()<br>                .antMatchers(<span class="hljs-string">&quot;/r/r1&quot;</span>).hasAuthority(<span class="hljs-string">&quot;p1&quot;</span>)<br>                .antMatchers(<span class="hljs-string">&quot;/r/r2&quot;</span>).hasAuthority(<span class="hljs-string">&quot;p2&quot;</span>)<br>                .antMatchers(<span class="hljs-string">&quot;/r/**&quot;</span>).authenticated()<span class="hljs-comment">//所有/r/**的请求必须认证通过</span><br>                .anyRequest().permitAll()<span class="hljs-comment">//除了/r/**，其它的请求可以访问</span><br>                .and()<br>                .formLogin()<span class="hljs-comment">//允许表单登录</span><br>                .successForwardUrl(<span class="hljs-string">&quot;/login-success&quot;</span>);<span class="hljs-comment">//自定义登录成功的页面地址</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringDataUserDetailsService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserDetailsService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    UserDao userDao;<br><br>    <span class="hljs-comment">//根据 账号查询用户信息</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> UserDetails <span class="hljs-title function_">loadUserByUsername</span><span class="hljs-params">(String username)</span> <span class="hljs-keyword">throws</span> UsernameNotFoundException &#123;<br><br>        <span class="hljs-comment">//将来连接数据库根据账号查询用户信息</span><br>        <span class="hljs-type">UserDto</span> <span class="hljs-variable">userDto</span> <span class="hljs-operator">=</span> userDao.getUserByUsername(username);<br>        <span class="hljs-keyword">if</span> (userDto == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//如果用户查不到，返回null，由provider来抛出异常</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//根据用户的id查询用户的权限</span><br>        List&lt;String&gt; permissions = userDao.findPermissionsByUserId(userDto.getId());<br>        <span class="hljs-comment">//将permissions转成数组</span><br>        String[] permissionArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[permissions.size()];<br>        permissions.toArray(permissionArray);<br>        <span class="hljs-type">UserDetails</span> <span class="hljs-variable">userDetails</span> <span class="hljs-operator">=</span> User.withUsername(userDto.getUsername()).password(userDto.getPassword()).authorities(permissionArray).build();<br>        <span class="hljs-keyword">return</span> userDetails;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-工作原理"><a href="#4-2-工作原理" class="headerlink" title="4.2 工作原理"></a>4.2 工作原理</h2><h3 id="4-2-1-结构总览"><a href="#4-2-1-结构总览" class="headerlink" title="4.2.1 结构总览"></a>4.2.1 结构总览</h3><p>Spring Security所解决的问题就是安全访问控制，而安全访问控制功能其实就是对所有进入系统的请求进行拦截， 校验每个请求是否能够访问它所期望的资源。根据前边知识的学习，可以通过Filter或 AOP等技术来实现，Spring Security对Web资源的保护是靠Filter实现的，所以从这个Filter来入手，逐步深入Spring Security原理。</p><p>当初始化Spring Security时，会创建一个名为 javaSpringSecurityFilterChain 的Servlet过滤器，类型为 org.springframework.security.web.FilterChainProxy，它实现了javax.servlet.Filter，因此外部的请求会经过此 类，下图是Spring Security过虑器链结构图：<br>14450</p><p>FilterChainProxy是一个代理，真正起作用的是FilterChainProxy中SecurityFilterChain所包含的各个Filter，同时 这些Filter作为Bean被Spring管理，它们是Spring Security核心，各有各的职责，但他们并不直接处理用户的认证，也不直接处理用户的授权，而是把它们交给了认证管理器（AuthenticationManager）和决策管理器 （AccessDecisionManager）进行处理，下图是FilterChainProxy相关类的UML图示。<br>14809<br>spring Security功能的实现主要是由一系列过滤器链相互配合完成。<br>14944<br>下面介绍过滤器链中主要的几个过滤器及其作用：<br>SecurityContextPersistenceFilter 这个Filter是整个拦截过程的入口和出口（也就是第一个和最后一个拦截 器），会在请求开始时从配置好的 SecurityContextRepository 中获取 SecurityContext，然后把它设置给 SecurityContextHolder。在请求完成后将 SecurityContextHolder 持有的 SecurityContext 再保存到配置好 的 SecurityContextRepository，同时清除 securityContextHolder 所持有的 SecurityContext；</p><p>UsernamePasswordAuthenticationFilter 用于处理来自表单提交的认证。该表单必须提供对应的用户名和密 码，其内部还有登录成功或失败后进行处理的 AuthenticationSuccessHandler 和 AuthenticationFailureHandler，这些都可以根据需求做相关改变；</p><p>FilterSecurityInterceptor 是用于保护web资源的，使用AccessDecisionManager对当前用户进行授权访问，前 面已经详细介绍过了；</p><p>ExceptionTranslationFilter 能够捕获来自 FilterChain 所有的异常，并进行处理。但是它只会处理两类异常： AuthenticationException 和 AccessDeniedException，其它的异常它会继续抛出。</p><h3 id="4-2-2-认证流程"><a href="#4-2-2-认证流程" class="headerlink" title="4.2.2.认证流程"></a>4.2.2.认证流程</h3><h4 id="4-2-2-1-认证流程"><a href="#4-2-2-1-认证流程" class="headerlink" title="4.2.2.1 认证流程"></a>4.2.2.1 认证流程</h4><p>15778<br>仔细分析认证过程：\</p><ol><li>用户提交用户名、密码被SecurityFilterChain中的 UsernamePasswordAuthenticationFilter 过滤器获取到， 封装为请求Authentication，通常情况下是UsernamePasswordAuthenticationToken这个实现类。</li><li>然后过滤器将Authentication提交至认证管理器（AuthenticationManager）进行认证</li><li>认证成功后， AuthenticationManager 身份管理器返回一个被填充满了信息的（包括上面提到的权限信息， 身份信息，细节信息，但密码通常会被移除） Authentication 实例。</li><li>SecurityContextHolder 安全上下文容器将第3步填充了信息的 Authentication ，通过 SecurityContextHolder.getContext().setAuthentication(…)方法，设置到其中。<br>可以看出AuthenticationManager接口（认证管理器）是认证相关的核心接口，也是发起认证的出发点，它 的实现类为ProviderManager。而Spring Security支持多种认证方式，因此ProviderManager维护着一个 List<AuthenticationProvider> 列表，存放多种认证方式，最终实际的认证工作是由 AuthenticationProvider完成的。咱们知道web表单的对应的AuthenticationProvider实现类为 DaoAuthenticationProvider，它的内部又维护着一个UserDetailsService负责UserDetails的获取。最终 AuthenticationProvider将UserDetails填充至Authentication。</li></ol><p>更多内容参考：<a href="https://www.cnblogs.com/abiu/p/14766551.html">https://www.cnblogs.com/abiu/p/14766551.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis面试题</title>
    <link href="/2024/09/28/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2024/09/28/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis相关面试题"><a href="#Redis相关面试题" class="headerlink" title="Redis相关面试题"></a>Redis相关面试题</h2><h4 id="什么是缓存穿透-怎么解决"><a href="#什么是缓存穿透-怎么解决" class="headerlink" title="什么是缓存穿透 ? 怎么解决 ?"></a>什么是缓存穿透 ? 怎么解决 ?</h4><blockquote><p>缓存穿透是指查询一个一定<strong>不存在</strong>的数据，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到 DB 去查询，可能导致 DB 挂掉。这种情况大概率是遭到了攻击。</p><p>解决方案的话，我们通常都会用布隆过滤器来解决它</p></blockquote><h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><blockquote><p>布隆过滤器主要是用于检索一个元素是否在一个集合中。</p><p>它的底层主要是先去初始化一个比较大数组，里面存放的二进制0或1。在一开始都是0，当一个key来了之后经过3次hash计算，模于数组长度找到数据的下标然后把数组中原来的0改为1，这样的话，三个数组的位置就能标明一个key的存在。查找的过程也是一样的。</p><p>当然是有缺点的，布隆过滤器有可能会产生一定的误判，我们一般可以设置这个误判率，大概不会超过5%，其实这个误判是必然存在的，要不就得增加数组的长度，其实已经算是很划分了，5%以内的误判率一般的项目也能接受，不至于高并发下压倒数据库。</p></blockquote><h4 id="什么是缓存击穿-怎么解决"><a href="#什么是缓存击穿-怎么解决" class="headerlink" title="什么是缓存击穿 ? 怎么解决 ?"></a>什么是缓存击穿 ? 怎么解决 ?</h4><blockquote><p>缓存击穿的意思是对于设置了过期时间的key，缓存在某个时间点过期的时候，恰好这时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端 DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把 DB 压垮。</p><p>解决方案有两种方式：</p><p>第一可以使用互斥锁：当缓存失效时，不立即去load db，先使用如 Redis 的 setnx 去设置一个互斥锁，当操作成功返回时再进行 load db的操作并回设缓存，否则重试get缓存的方法</p><p>第二种方案可以设置当前key逻辑过期，大概是思路如下：</p><p>①：在设置key的时候，设置一个过期时间字段一块存入缓存中，不给当前key设置过期时间</p><p>②：当查询的时候，从redis取出数据后判断时间是否过期</p><p>③：如果过期则开通另外一个线程进行数据同步，当前线程正常返回数据，这个数据不是最新</p><p>当然两种方案各有利弊：</p><p>如果选择数据的强一致性，建议使用分布式锁的方案，性能上可能没那么高，锁需要等，也有可能产生死锁的问题</p><p>如果选择key的逻辑删除，则优先考虑的高可用性，性能比较高，但是数据同步这块做不到强一致。</p></blockquote><h4 id="什么是缓存雪崩-怎么解决"><a href="#什么是缓存雪崩-怎么解决" class="headerlink" title="什么是缓存雪崩 ? 怎么解决 ?"></a>什么是缓存雪崩 ? 怎么解决 ?</h4><blockquote><p>缓存雪崩意思是设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB 瞬时压力过重雪崩。与缓存击穿的区别：雪崩是很多key，击穿是某一个key缓存。</p><p>解决方案主要是可以将缓存失效时间分散开，比如可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p></blockquote><h4 id="redis做为缓存，mysql的数据如何与redis进行同步呢？（双写一致性）"><a href="#redis做为缓存，mysql的数据如何与redis进行同步呢？（双写一致性）" class="headerlink" title="redis做为缓存，mysql的数据如何与redis进行同步呢？（双写一致性）"></a>redis做为缓存，mysql的数据如何与redis进行同步呢？（双写一致性）</h4><blockquote><p>强一致：采用的是redisson实现的读写锁，在读的时候添加共享锁，可以保证读读不互斥，读写互斥。当我们更新数据的时候，添加排他锁，它是读写，读读都互斥，这样就能保证在写数据的同时是不会让其他线程读数据的，避免了脏数据。这里面需要注意的是读方法和写方法上需要使用同一把锁才行。</p><p>有延时：延迟双删，mq通知</p></blockquote><h4 id="redis做为缓存，数据的持久化是怎么做的？"><a href="#redis做为缓存，数据的持久化是怎么做的？" class="headerlink" title="redis做为缓存，数据的持久化是怎么做的？"></a>redis做为缓存，数据的持久化是怎么做的？</h4><blockquote><p>在Redis中提供了两种数据持久化的方式：1、RDB  2、AOF</p><p>RDB是一个快照文件，它是把redis内存存储的数据写到磁盘上，当redis实例宕机恢复数据的时候，方便从RDB的快照文件中恢复数据。Redis内部有触发RDB的机制，如60秒内100次修改</p><p>AOF的含义是追加文件，当redis操作写命令的时候，都会存储这个文件中，当redis实例宕机恢复数据的时候，会从这个文件中再次执行一遍命令来恢复数据。</p><p>RDB因为是二进制文件，在保存的时候体积也是比较小的，它恢复的比较快，但是它有可能会丢数据，我们通常在项目中也会使用AOF来恢复数据，虽然AOF恢复的速度慢一些，但是它丢数据的风险要小很多，在AOF文件中可以设置刷盘策略，我们当时设置的就是每秒批量写入一次命令</p></blockquote><h4 id="Redis的数据过期策略有哪些"><a href="#Redis的数据过期策略有哪些" class="headerlink" title="Redis的数据过期策略有哪些 ?"></a>Redis的数据过期策略有哪些 ?</h4><blockquote><p>第一种是惰性删除，在设置该key过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key。</p><p>第二种是 定期删除，就是说每隔一段时间，我们就对一些key进行检查，删除里面过期的key</p><p>定期清理的两种模式：</p><ul><li>SLOW模式是定时任务，执行频率默认为10hz，每次不超过25ms，以通过修改配置文件redis.conf 的 <strong>hz</strong> 选项来调整这个次数</li><li>FAST模式执行频率不固定，每次事件循环会尝试执行，但两次间隔不低于2ms，每次耗时不超过1ms</li></ul><p>Redis的过期删除策略：<strong>惰性删除 + 定期删除</strong>两种策略进行配合使用。</p></blockquote><h4 id="Redis的数据淘汰策略有哪些"><a href="#Redis的数据淘汰策略有哪些" class="headerlink" title="Redis的数据淘汰策略有哪些 ?"></a>Redis的数据淘汰策略有哪些 ?</h4><blockquote><p>在redis中提供了很多种，默认是noeviction，不删除任何数据，内部不足直接报错</p><p>是可以在redis的配置文件中进行设置的，里面有两个非常重要的概念，一个是LRU，另外一个是LFU</p><p>LRU的意思就是最少最近使用，用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</p><p>LFU的意思是最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高</p><p>我们在项目设置的allkeys-lru，挑选最近最少使用的数据淘汰，把一些经常访问的key留在redis中</p></blockquote><h4 id="数据库有1000万数据-Redis只能缓存20w数据-如何保证Redis中的数据都是热点数据"><a href="#数据库有1000万数据-Redis只能缓存20w数据-如何保证Redis中的数据都是热点数据" class="headerlink" title="数据库有1000万数据 ,Redis只能缓存20w数据, 如何保证Redis中的数据都是热点数据 ?"></a>数据库有1000万数据 ,Redis只能缓存20w数据, 如何保证Redis中的数据都是热点数据 ?</h4><blockquote><p>这个要看redis的数据淘汰策略是什么，如果是默认的配置，redis内存用完以后则直接报错。我们当时设置的 allkeys-lru 策略。把最近最常访问的数据留在缓存中。</p></blockquote><h4 id="Redis分布式锁如何实现"><a href="#Redis分布式锁如何实现" class="headerlink" title="Redis分布式锁如何实现 ?"></a>Redis分布式锁如何实现 ?</h4><blockquote><p>在redis中提供了一个命令setnx(SET if not exists)</p><p>由于redis的单线程的，用了命令之后，只能有一个客户端对某一个key设置值，在没有过期或删除key的时候是其他客户端是不能设置这个key的</p></blockquote><h4 id="如何控制Redis实现分布式锁有效时长"><a href="#如何控制Redis实现分布式锁有效时长" class="headerlink" title="如何控制Redis实现分布式锁有效时长"></a>如何控制Redis实现分布式锁有效时长</h4><blockquote><p>redis的setnx指令不好控制这个问题，我们当时采用的redis的一个框架redisson实现的。</p><p>在redisson中需要手动加锁，并且可以控制锁的失效时间和等待时间，当锁住的一个业务还没有执行完成的时候，在redisson中引入了一个看门狗机制，就是说每隔一段时间就检查当前业务是否还持有锁，如果持有就增加加锁的持有时间，当业务执行完成之后需要使用释放锁就可以了</p><p>还有一个好处就是，在高并发下，一个业务有可能会执行很快，先客户1持有锁的时候，客户2来了以后并不会马上拒绝，它会自旋不断尝试获取锁，如果客户1释放之后，客户2就可以马上持有锁，性能也得到了提升。</p></blockquote><h4 id="redisson实现的分布式锁是可重入的吗？"><a href="#redisson实现的分布式锁是可重入的吗？" class="headerlink" title="redisson实现的分布式锁是可重入的吗？"></a>redisson实现的分布式锁是可重入的吗？</h4><blockquote><p>是可以重入的。这样做是为了避免死锁的产生。这个重入其实在内部就是判断是否是当前线程持有的锁，如果是当前线程持有的锁就会计数，如果释放锁就会在计算上减一。在存储数据的时候采用的hash结构，大key可以按照自己的业务进行定制，其中小key是当前线程的唯一标识，value是当前线程重入的次数</p></blockquote><h4 id="redisson实现的分布式锁能解决主从一致性的问题吗"><a href="#redisson实现的分布式锁能解决主从一致性的问题吗" class="headerlink" title="redisson实现的分布式锁能解决主从一致性的问题吗"></a>redisson实现的分布式锁能解决主从一致性的问题吗</h4><blockquote><p>这个是不能的，比如，当线程1加锁成功后，master节点数据会异步复制到slave节点，此时当前持有Redis锁的master节点宕机，slave节点被提升为新的master节点，假如现在来了一个线程2，再次加锁，会在新的master节点上加锁成功，这个时候就会出现两个节点同时持有一把锁的问题。</p><p>我们可以利用redisson提供的红锁来解决这个问题，它的主要作用是，不能只在一个redis实例上创建锁，应该是在多个redis实例上创建锁，并且要求在大多数redis节点上都成功创建锁，红锁中要求是redis的节点数量要过半。这样就能避免线程1加锁成功后master节点宕机导致线程2成功加锁到新的master节点上的问题了。</p><p>但是，如果使用了红锁，因为需要同时在多个节点上都添加锁，性能就变的很低了，并且运维维护成本也非常高，所以，我们一般在项目中也不会直接使用红锁，并且官方也暂时废弃了这个红锁</p></blockquote><h4 id="如果业务非要保证数据的强一致性，这个该怎么解决呢？"><a href="#如果业务非要保证数据的强一致性，这个该怎么解决呢？" class="headerlink" title="如果业务非要保证数据的强一致性，这个该怎么解决呢？"></a>如果业务非要保证数据的强一致性，这个该怎么解决呢？</h4><blockquote><p>redis本身就是支持高可用的，做到强一致性，就非常影响性能，所以，如果有强一致性要求高的业务，建议使用zookeeper实现的分布式锁，它是可以保证强一致性的。</p></blockquote><h4 id="Redis集群有哪些方案"><a href="#Redis集群有哪些方案" class="headerlink" title="Redis集群有哪些方案?"></a>Redis集群有哪些方案?</h4><blockquote><p>在Redis中提供的集群方案总共有三种：主从复制、哨兵模式、Redis分片集群</p><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，可以搭建主从集群，实现读写分离。一般都是一主多从，主节点负责写数据，从节点负责读数据，主节点写入数据之后，需要把数据同步到从节点中</p><p>主从同步分为了两个阶段，一个是全量同步，一个是增量同步</p><p>全量同步是指从节点第一次与主节点建立连接的时候使用全量同步，流程是这样的：</p><p>第一：从节点请求主节点同步数据，其中从节点会携带自己的replication id和offset偏移量。</p><p>第二：主节点判断是否是第一次请求，主要判断的依据就是，主节点与从节点是否是同一个replication id，如果不是，就说明是第一次同步，那主节点就会把自己的replication id和offset发送给从节点，让从节点与主节点的信息保持一致。</p><p>第三：在同时主节点会执行bgsave，生成rdb文件后，发送给从节点去执行，从节点先把自己的数据清空，然后执行主节点发送过来的rdb文件，这样就保持了一致</p><p>当然，如果在rdb生成执行期间，依然有请求到了主节点，而主节点会以命令的方式记录到缓冲区，缓冲区是一个日志文件，最后把这个日志文件发送给从节点，这样就能保证主节点与从节点完全一致了，后期再同步数据的时候，都是依赖于这个日志文件，这个就是全量同步</p><p>增量同步指的是，当从节点服务重启之后，数据就不一致了，所以这个时候，从节点会请求主节点同步数据，主节点还是判断不是第一次请求，不是第一次就获取从节点的offset值，然后主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步</p></blockquote><h4 id="Redis是单线程的，但是为什么还那么快？"><a href="#Redis是单线程的，但是为什么还那么快？" class="headerlink" title="Redis是单线程的，但是为什么还那么快？"></a>Redis是单线程的，但是为什么还那么快？</h4><blockquote><p>1、完全基于内存的，C语言编写</p><p>2、采用单线程，避免不必要的上下文切换可竞争条件</p><p>3、使用多路I&#x2F;O复用模型，非阻塞IO</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 面试题---容器部分</title>
    <link href="/2024/08/28/java%E9%9B%86%E5%90%88/"/>
    <url>/2024/08/28/java%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<h2 id="Java集合相关面试题"><a href="#Java集合相关面试题" class="headerlink" title="Java集合相关面试题"></a>Java集合相关面试题</h2><ul><li>ArrayList底层实现是数组</li><li>LinkedList底层实现是双向链表</li><li>HashMap的底层实现使用了包括数组、链表、散列表、红黑树等多种数据结构</li></ul><h3 id="Java容器有哪些"><a href="#Java容器有哪些" class="headerlink" title="Java容器有哪些"></a>Java容器有哪些</h3><blockquote><ul><li>Collection 的子类 List、Set<ul><li>List 的子类 ArrayList、LinkedList等</li><li>Set 的子类 HashSet、TreeSet等</li></ul></li><li>Map 的子类 HashMap、TreeMap</li></ul></blockquote><h3 id="ArrayList基本原理"><a href="#ArrayList基本原理" class="headerlink" title="ArrayList基本原理"></a>ArrayList基本原理</h3><blockquote><ul><li>底层是使用动态数值实现的</li><li>未指定大小时初始容量为零，返回的是统一的空实例，并且在第一次添加数据时才会扩容为默认的10；指定大小则创建对应大小的数组</li><li>扩容时每次扩容原来的1.5倍，每次扩容都需要拷贝数组</li><li>添加数据时，先检查加入后时候小于数组容量，若大于，则先执行扩容逻辑后添加</li></ul></blockquote><h4 id="面试题-ArrayList-list-new-ArrayList-10-中的list扩容几次"><a href="#面试题-ArrayList-list-new-ArrayList-10-中的list扩容几次" class="headerlink" title="面试题-ArrayList list&#x3D;new ArrayList(10)中的list扩容几次"></a>面试题-ArrayList list&#x3D;new ArrayList(10)中的list扩容几次</h4><blockquote><p>直接指定了初始数组大小，未扩容</p></blockquote><h4 id="面试题-如何实现数组和List之间的转换"><a href="#面试题-如何实现数组和List之间的转换" class="headerlink" title="面试题-如何实现数组和List之间的转换"></a>面试题-如何实现数组和List之间的转换</h4><blockquote><ul><li><p>数组转List，使用JDK中的java.util.Arrays工具类的asList方法</p><p><strong>注意：</strong>Arrays.asList转换list之后，如果修改了数组的内容，list会受影响，因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址</p></li><li><p>List转数组，使用List的toArray方法。无参toArray方法返回 Object数组，传入初始化长度的数组对象，返回该对象数组</p></li></ul></blockquote><h4 id="面试题-ArrayList和LinkedList的区别是什么？"><a href="#面试题-ArrayList和LinkedList的区别是什么？" class="headerlink" title="面试题-ArrayList和LinkedList的区别是什么？"></a>面试题-ArrayList和LinkedList的区别是什么？</h4><blockquote><ul><li>底层数据</li></ul><ul><li><p>ArrayList 是动态数组的数据结构实现</p></li><li><p>LinkedList 是双向链表的数据结构实现</p></li></ul><ul><li>操作数据效率</li></ul><ul><li>ArrayList按照下标查询的时间复杂度O(1)【内存是连续的，根据寻址公式】， LinkedList不支持下标查询</li><li>查找（未知索引）： ArrayList需要遍历，链表也需要链表，时间复杂度都是O(n)</li><li>新增和删除<ul><li>ArrayList尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)</li><li>LinkedList头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n)</li></ul></li></ul><ul><li>内存空间占用</li></ul><ul><li><p>ArrayList底层是数组，内存连续，节省内存</p></li><li><p>LinkedList 是双向链表需要存储数据，和两个指针，更占用内存</p></li></ul><ul><li>线程安全</li></ul><ul><li>ArrayList和LinkedList都不是线程安全的</li><li>如果需要保证线程安全，有两种方案：<ul><li>在方法内使用，局部变量则是线程安全的</li><li>使用线程安全的ArrayList和LinkedList</li></ul></li></ul></blockquote><h3 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h3><blockquote><p>HashMap的数据结构： 底层使用hash表数据结构，即数组和链表或红黑树</p><ol><li><p>当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标 </p></li><li><p>存储时，如果出现hash值相同的key，此时有两种情况。</p></li></ol><p>  a. 如果key相同，则覆盖原始值；</p><p>  b. 如果key不同（出现冲突），则将当前的key-value放入链表或红黑树中 </p><ol start="3"><li>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</li></ol><p><strong>注意</strong></p><ul><li><p>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p></li><li><p>jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8） 时并且数组长度达到64时，将链表转化为红黑树，以减少搜索时间。扩容 resize( ) 时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表</p></li></ul></blockquote><h4 id="面试题-HashMap的put方法的具体流程"><a href="#面试题-HashMap的put方法的具体流程" class="headerlink" title="面试题-HashMap的put方法的具体流程"></a>面试题-HashMap的put方法的具体流程</h4><blockquote><ol><li><p>判断键值对数组table是否为空或为null，否则执行resize()进行扩容（初始化）</p></li><li><p>根据键值key计算hash值得到数组索引</p></li><li><p>判断table[i]&#x3D;&#x3D;null，条件成立，直接新建节点添加</p></li><li><p>如果table[i]&#x3D;&#x3D;null ,不成立</p><p>4.1 判断table[i]的首个元素是否和key一样，如果相同直接覆盖value</p><p>4.2 判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对</p><p>4.3 遍历table[i]，链表的尾部插入数据，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操 作，遍历过程中若发现key已经存在直接覆盖value</p></li><li><p>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组长度*0.75），如果超过，进行扩容。</p></li></ol></blockquote><h4 id="面试题-讲一讲HashMap的扩容机制"><a href="#面试题-讲一讲HashMap的扩容机制" class="headerlink" title="面试题-讲一讲HashMap的扩容机制"></a>面试题-讲一讲HashMap的扩容机制</h4><blockquote><ul><li><p>在添加元素或初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）</p></li><li><p>每次扩容的时候，都是扩容之前容量的2倍； </p></li><li><p>扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中</p><ul><li>没有hash冲突的节点，则直接使用 e.hash &amp; (newCap - 1) 计算新数组的索引位置</li><li>如果是红黑树，走红黑树的添加</li><li>如果是链表，则需要遍历链表，可能需要拆分链表，判断(e.hash &amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</li></ul></li></ul></blockquote><h4 id="面试题-HashSet与HashMap的区别"><a href="#面试题-HashSet与HashMap的区别" class="headerlink" title="面试题-HashSet与HashMap的区别"></a>面试题-HashSet与HashMap的区别</h4><blockquote><p>(1)HashSet实现了Set接口, 仅存储对象; HashMap实现了 Map接口, 存储的是键值对.</p><p>(2)HashSet底层其实是用HashMap实现存储的, HashSet封装了一系列HashMap的方法. 依靠HashMap来存储元素值,(利用hashMap的key键进行存储), 而value值默认为Object对象. 所以HashSet也不允许出现重复值, 判断标准和HashMap判断标准相同, 两个元素的hashCode相等并且通过equals()方法返回true.</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Exception相关知识总结</title>
    <link href="/2024/01/10/Java%20SE%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <url>/2024/01/10/Java%20SE%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaSE中薄弱知识笔记–结合项目"><a href="#JavaSE中薄弱知识笔记–结合项目" class="headerlink" title="JavaSE中薄弱知识笔记–结合项目"></a>JavaSE中薄弱知识笔记–结合项目</h1><h2 id=""><a href="#" class="headerlink" title="&#x3D;&#x3D;"></a>&#x3D;&#x3D;</h2><p>在 Java 中，基本数据类型使用 &#x3D;&#x3D; 运算符进行比较时，会涉及到类型转换和值的比较，下面详细介绍不同基本数据类型使用 &#x3D;&#x3D; 比较的规则。<br>基本规则概述<br>&#x3D;&#x3D; 对于基本数据类型，比较的是它们的值是否相等。<br>当使用 &#x3D;&#x3D; 比较不同类型的基本数据类型时，Java 会进行自动类型转换（也称为隐式类型转换），将范围小的类型转换为范围大的类型，然后再比较值。<br>注意事项<br>数据范围问题：在进行类型转换时，如果范围小的类型的值超出了范围大的类型的表示范围，可能会导致数据丢失或意外结果。不过基本数据类型的隐式转换是安全的，因为总是从小范围类型转换为大范围类型。<br>boolean 类型：boolean 类型只能和 boolean 类型进行 &#x3D;&#x3D; 比较，不能与其他基本数据类型比较，否则会导致编译错误。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举是一种特殊的类，它的格式是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> 枚举类名&#123;<br>    枚举项<span class="hljs-number">1</span>,枚举项<span class="hljs-number">2</span>,枚举项<span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实枚举项就表示枚举类的对象，只是这些对象在定义枚举类时就预先写好了，以后就只能用这几个固定的对象。</p><p>我们用代码演示一下，定义一个枚举类A，在枚举类中定义三个枚举项X, Y, Z</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">A</span>&#123;<br>    X,Y,Z;<br>&#125;<br></code></pre></td></tr></table></figure><p>想要获取枚举类中的枚举项，只需要用类名调用就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-comment">//获取枚举A类的，枚举项</span><br>        <span class="hljs-type">A</span> <span class="hljs-variable">a1</span> <span class="hljs-operator">=</span> A.X;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a2</span> <span class="hljs-operator">=</span> A.Y;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a3</span> <span class="hljs-operator">=</span> A.Z;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>刚才说，枚举项实际上是枚举类的对象，这一点其实可以通过反编译的形式来验证（需要用到反编译的命令，这里不能直接将字节码拖进idea反编译）<br>2865</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>框架面试题</title>
    <link href="/2023/09/02/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/09/02/%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="框架相关面试题"><a href="#框架相关面试题" class="headerlink" title="框架相关面试题"></a>框架相关面试题</h2><h4 id="Spring框架中的单例bean是线程安全的吗？"><a href="#Spring框架中的单例bean是线程安全的吗？" class="headerlink" title="Spring框架中的单例bean是线程安全的吗？"></a>Spring框架中的单例bean是线程安全的吗？</h4><blockquote><p>不是线程安全的，是这样的</p><p>当多用户同时请求一个服务时，容器会给每一个请求分配一个线程，这是多个线程会并发执行该请求对应的业务逻辑（成员方法），如果该处理逻辑中有对该单列状态的修改（体现为该单例的成员属性），则必须考虑线程同步问题。</p><p>Spring框架并没有对单例bean进行任何多线程的封装处理。关于单例bean的线程安全和并发问题需要开发者自行去搞定。</p><p>比如：我们通常在项目中使用的Spring bean都是不可可变的状态(比如Service类和DAO类)，所以在某种程度上说Spring的单例bean是线程安全的。</p><p>如果你的bean有多种状态的话（比如 View Model对象），就需要自行保证线程安全。最浅显的解决办法就是将多态bean的作用由“<strong>singleton</strong>”变更为“<strong>prototype</strong>”。</p></blockquote><h4 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h4><blockquote><p>aop是面向切面编程，在spring中用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合，一般比如可以做为公共日志保存，事务处理等</p></blockquote><h4 id="你们项目中有没有使用到AOP"><a href="#你们项目中有没有使用到AOP" class="headerlink" title="你们项目中有没有使用到AOP"></a>你们项目中有没有使用到AOP</h4><blockquote><p>我们当时在后台管理系统中，就是使用aop来记录了系统的操作日志</p><p>主要思路是这样的，使用aop中的环绕通知+切点表达式，这个表达式就是要找到要记录日志的方法，然后通过环绕通知的参数获取请求方法的参数，比如类信息、方法信息、注解、请求方式等，获取到这些参数以后，保存到数据库</p><p>在项目中自定义注解，自动填充数据的更新时间和创造时间</p></blockquote><h4 id="Spring中的事务是如何实现的"><a href="#Spring中的事务是如何实现的" class="headerlink" title="Spring中的事务是如何实现的"></a>Spring中的事务是如何实现的</h4><blockquote><p>spring实现的事务本质就是aop完成，对方法前后进行拦截，在执行方法之前开启事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p></blockquote><h4 id="Spring中事务失效的场景有哪些"><a href="#Spring中事务失效的场景有哪些" class="headerlink" title="Spring中事务失效的场景有哪些"></a>Spring中事务失效的场景有哪些</h4><blockquote><p>第一个，如果方法上异常捕获处理，自己处理了异常，没有抛出，就会导致事务失效，所以一般处理了异常以后，别忘了跑出去就行了</p><p>第二个，如果方法抛出检查异常，如果报错也会导致事务失效，最后在spring事务的注解上，就是@Transactional上配置rollbackFor属性为Exception，这样别管是什么异常，都会回滚事务</p><p>第三，我之前还遇到过一个，如果方法上不是public修饰的，也会导致事务失效</p><p>第四，在方法内使用this调用其他方法，这些方法如果没有暴露出去也会造成事务失效</p></blockquote><h4 id="Spring的bean的生命"><a href="#Spring的bean的生命" class="headerlink" title="Spring的bean的生命"></a>Spring的bean的生命</h4><blockquote><p>首先会通过一个非常重要的类，叫做BeanDefinition获取bean的定义信息，这里面就封装了bean的所有信息，比如，类的全路径，是否是延迟加载，是否是单例等等这些信息</p><p>在创建bean的时候，第一步是调用构造函数实例化bean</p><p>第二步是bean的依赖注入，比如一些set方法注入，像平时开发用的@Autowire都是这一步完成</p><p>第三步是处理Aware接口，如果某一个bean实现了Aware接口就会重写方法执行</p><p>第四步是bean的后置处理器BeanPostProcessor，这个是前置处理器</p><p>第五步是初始化方法，比如实现了接口InitializingBean或者自定义了方法init-method标签或@PostContruct</p><p>第六步是执行了bean的后置处理器BeanPostProcessor，主要是对bean进行增强，有可能在这里产生代理对象</p><p>最后一步是销毁bean</p></blockquote><h4 id="Spring中的循环引用"><a href="#Spring中的循环引用" class="headerlink" title="Spring中的循环引用"></a>Spring中的循环引用</h4><blockquote><p>循环依赖：循环依赖其实就是循环引用,也就是两个或两个以上的bean互相持有对方,最终形成闭环。比如A依赖于B,B依赖于A</p><p>循环依赖在spring中是允许存在，spring框架依据三级缓存已经解决了大部分的循环依赖</p><p>①一级缓存：单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象</p><p>②二级缓存：缓存早期的bean对象（生命周期还没走完）</p><p>③三级缓存：缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的</p><p>具体解决流程：</p><p>第一，先实例A对象，同时会创建ObjectFactory对象存入三级缓存singletonFactories  </p><p>第二，A在初始化的时候需要B对象，这个走B的创建的逻辑</p><p>第三，B实例化完成，也会创建ObjectFactory对象存入三级缓存singletonFactories  </p><p>第四，B需要注入A，通过三级缓存中获取ObjectFactory来生成一个A的对象同时存入二级缓存，这个是有两种情况，一个是可能是A的普通对象，另外一个是A的代理对象，都可以让ObjectFactory来生产对应的对象，这也是三级缓存的关键</p><p>第五，B通过从通过二级缓存earlySingletonObjects  获得到A的对象后可以正常注入，B创建成功，存入一级缓存singletonObjects  </p><p>第六，回到A对象初始化，因为B对象已经创建完成，则可以直接注入B，A创建成功存入一次缓存singletonObjects </p><p>第七，二级缓存中的临时对象A清除 </p></blockquote><h4 id="构造方法出现了循环依赖怎么解决？"><a href="#构造方法出现了循环依赖怎么解决？" class="headerlink" title="构造方法出现了循环依赖怎么解决？"></a>构造方法出现了循环依赖怎么解决？</h4><blockquote><p>由于bean的生命周期中构造函数是第一个执行的，spring框架并不能解决构造函数的的依赖注入，可以使用@Lazy懒加载，什么时候需要对象再进行bean对象的创建</p></blockquote><h4 id="SpringMVC的执行流程"><a href="#SpringMVC的执行流程" class="headerlink" title="SpringMVC的执行流程"></a>SpringMVC的执行流程</h4><blockquote><p>1、用户发送出请求到前端控制器DispatcherServlet，这是一个调度中心</p><p>2、DispatcherServlet收到请求调用HandlerMapping（处理器映射器）。</p><p>3、HandlerMapping找到具体的处理器(可查找xml配置或注解配置)，生成处理器对象及处理器拦截器(如果有)，再一起返回给DispatcherServlet。</p><p>4、DispatcherServlet调用HandlerAdapter（处理器适配器）。</p><p>5、HandlerAdapter经过适配调用具体的处理器（Handler&#x2F;Controller）。</p><p>6、Controller执行完成返回ModelAndView对象。</p><p>7、HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet。</p><p>8、DispatcherServlet将ModelAndView传给ViewReslover（视图解析器）。</p><p>9、ViewReslover解析后返回具体View（视图）。</p><p>10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</p><p>11、DispatcherServlet响应用户。</p><p>当然现在的开发，基本都是前后端分离的开发的，并没有视图这些，一般都是handler中使用Response直接结果返回</p></blockquote><h4 id="Springboot自动配置原理"><a href="#Springboot自动配置原理" class="headerlink" title="Springboot自动配置原理"></a>Springboot自动配置原理</h4><blockquote><p>在Spring Boot项目中的引导类上有一个注解@SpringBootApplication，这个注解是对三个注解进行了封装，分别是：</p><ul><li><p>@SpringBootConfiguration</p></li><li><p>@EnableAutoConfiguration</p></li><li><p>@ComponentScan</p></li></ul><p>其中<code>@EnableAutoConfiguration</code>是实现自动化配置的核心注解。 </p><p>该注解通过<code>@Import</code>注解导入对应的配置选择器。关键的是内部就是读取了该项目和该项目引用的Jar包的的classpath路径下<strong>META-INF&#x2F;spring.factories</strong>文件中的所配置的类的全类名。 </p><p>在这些配置类中所定义的Bean会根据条件注解所<strong>指定的条件来决定</strong>是否需要将其导入到Spring容器中。</p><p>一般条件判断会有像<code>@ConditionalOnClass</code>这样的注解，判断是否有对应的class文件，如果有则加载该类，把这个配置类的所有的Bean放入spring容器中使用。</p></blockquote><h4 id="Spring-的常见注解有哪些？？"><a href="#Spring-的常见注解有哪些？？" class="headerlink" title="Spring 的常见注解有哪些？？"></a>Spring 的常见注解有哪些？？</h4><blockquote><p>第一类是：声明bean，有@Component、@Service、@Repository、@Controller</p><p>第二类是：依赖注入相关的，有@Autowired、@Qualifier、@Resourse</p><p>第三类是：设置作用域 @Scope</p><p>第四类是：spring配置相关的，比如@Configuration，@ComponentScan 和 @Bean </p><p>第五类是：跟aop相关做增强的注解  @Aspect，@Before，@After，@Around，@Pointcut</p></blockquote><h4 id="SpringMVC常见的注解有哪些？"><a href="#SpringMVC常见的注解有哪些？" class="headerlink" title="SpringMVC常见的注解有哪些？"></a>SpringMVC常见的注解有哪些？</h4><blockquote><p>@RequestMapping：用于映射请求路径；</p><p>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象；</p><p>@RequestParam：指定请求参数的名称；</p><p>@PathViriable：从请求路径下中获取请求参数(&#x2F;user&#x2F;{id})，传递给方法的形式参数；@ResponseBody：注解实现将controller方法返回对象转化为json对象响应给客户端。@RequestHeader：获取指定的请求头数据，还有像@PostMapping、@GetMapping这些。</p></blockquote><h4 id="Springboot常见注解有哪些？"><a href="#Springboot常见注解有哪些？" class="headerlink" title="Springboot常见注解有哪些？"></a>Springboot常见注解有哪些？</h4><blockquote><p>Spring Boot的核心注解是@SpringBootApplication , 他由几个注解组成 : </p><ul><li>@SpringBootConfiguration： 组合了- @Configuration注解，实现配置文件的功能；</li><li>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项</li><li>@ComponentScan：Spring组件扫描</li></ul></blockquote><h4 id="MyBatis执行流程"><a href="#MyBatis执行流程" class="headerlink" title="MyBatis执行流程"></a>MyBatis执行流程</h4><blockquote><p>①读取MyBatis配置文件：mybatis-config.xml加载运行环境和映射文件</p><p>②构造会话工厂SqlSessionFactory，一个项目只需要一个，单例的，一般由spring进行管理</p><p>③会话工厂创建SqlSession对象，这里面就含了执行SQL语句的所有方法</p><p>④操作数据库的接口，Executor执行器，同时负责查询缓存的维护</p><p>⑤Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息</p><p>⑥输入参数映射</p><p>⑦输出结果映射</p></blockquote><h4 id="Mybatis是否支持延迟加载？"><a href="#Mybatis是否支持延迟加载？" class="headerlink" title="Mybatis是否支持延迟加载？"></a>Mybatis是否支持延迟加载？</h4><blockquote><p>延迟加载的意思是：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。</p><p>Mybatis支持一对一关联对象和一对多关联集合对象的延迟加载</p><p>在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;true|false，默认是关闭的</p></blockquote><h4 id="延迟加载的底层原理知道吗？"><a href="#延迟加载的底层原理知道吗？" class="headerlink" title="延迟加载的底层原理知道吗？"></a>延迟加载的底层原理知道吗？</h4><blockquote><p>延迟加载在底层主要使用的CGLIB动态代理完成的</p><p>第一是，使用CGLIB创建目标对象的代理对象，这里的目标对象就是开启了延迟加载的mapper</p><p>第二个是当调用目标方法时，进入拦截器invoke方法，发现目标方法是null值，再执行sql查询</p><p>第三个是获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了</p></blockquote><h4 id="Mybatis的一级、二级缓存用过吗？"><a href="#Mybatis的一级、二级缓存用过吗？" class="headerlink" title="Mybatis的一级、二级缓存用过吗？"></a>Mybatis的一级、二级缓存用过吗？</h4><blockquote><p>mybatis的一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存</p><p>关于二级缓存需要单独开启</p><p>二级缓存是基于namespace和mapper的作用域起作用的，不是依赖于SQL session，默认也是采用 PerpetualCache，HashMap 存储。</p><p>如果想要开启二级缓存需要在全局配置文件和映射文件中开启配置才行。</p></blockquote><h4 id="Mybatis的二级缓存什么时候会清理缓存中的数据"><a href="#Mybatis的二级缓存什么时候会清理缓存中的数据" class="headerlink" title="Mybatis的二级缓存什么时候会清理缓存中的数据"></a>Mybatis的二级缓存什么时候会清理缓存中的数据</h4><blockquote><p>当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了新增、修改、删除操作后，默认该作用域下所有 select 中的缓存将被 clear。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>框架面试题</title>
    <link href="/2023/09/01/hexo%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/09/01/hexo%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo基本操作"><a href="#hexo基本操作" class="headerlink" title="hexo基本操作"></a>hexo基本操作</h2><ol><li>hexo clean   清除缓存</li><li>hexo g       编译生成</li><li>hexo deploy  部署到github</li><li>hexo s      本地运行查看</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>基本</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
